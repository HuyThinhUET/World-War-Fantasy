int binhchungs[]=  {-1,   1,    2,    3,    1,    2,    3,    4};
int HPs[] =        {-1,   150,  100,  50,   200,  200,  200,  2000};
int dames[] =      {-1,   34,   20,   250,  50,   40,   50,   300};
int SPDatks[] =    {-1,   24,   24,   24,   24,   24,   24,   24};
int ranges[] =     {-1,   5,    350,  5,    5,    350,  5,    5};
int SPDs[] =       {-1,   1,    1,    2,    1,    1,    1,    2};
int costs[]=       {-1,   60,   55,   50,   100,  110,  120,  1500};
int killrewards[]= {-1,   75,   70,   65,   135,  145,  155,  2000};

struct Troop{
    LTexture Textt;
    int stt;
    int l, r;
    int id;
    int phe;
    int binhchung;
    int HP;
    int dame;
    int SPDatk;
    int range;
    int SPD;
    int deadframe;
    int attackframe;
    int cooldownframe;
    int cost;
    int killreward;

    Troop(){}

    Troop(int idd, int thutu, int phee) {
        stt=thutu;
        if(!phee) {l=0, r=l+96;}
        else {r=1200, l=r-96;}
        if(idd==7) {r=l+160;}
        Textt.xx=l;
        id=idd;
        phe=phee;
        binhchung = binhchungs[idd];
        HP = HPs[idd];
        dame = dames[idd];
        SPDatk = SPDatks[idd];
        range = ranges[idd];
        if(!phee) SPD = SPDs[idd];
        else SPD = -SPDs[idd];
        deadframe=0;
        attackframe=0;
        cooldownframe=0;
        cost=costs[idd];
        killreward=killrewards[idd];
    }
};

vector<Troop> danhsachquan;

bool CreateTroop(int id, int phe, bool hard=false) { //nếu là tạo lính cho phe player thì chỉ cần nhập 2 tham số đầu vào do hard mặc định bằng false
    if(phe && cntlinhbot>=8) return false;
    if(!phe && cntlinhplayer>=8) return false;
    if(!phe && playergold<costs[id]) return false;

    Troop linh(id, ++cntlinh, phe);
    if(phe && hard) linh.HP += linh.HP/2;
    if(phe && hard) linh.killreward -= 10;
    if(!phe) playergold -= linh.cost;

    danhsachquan.push_back(linh);
    if(!phe) binhchungplayer.push(binhchungs[id]);
    if(phe) cntlinhbot++;
    else cntlinhplayer++;

    return true;
}

void ClearTroop(int thutu) {
    for(int i=0; i<danhsachquan.size(); i++)
        if(danhsachquan[i].stt == thutu) {
            if(danhsachquan[i].phe) {
                cntlinhbot--;
                playergold+=danhsachquan[i].killreward;
            }
            else {
                binhchungplayer.pop();
                cntlinhplayer--;
            }

            danhsachquan.erase( danhsachquan.begin()+i );
            break;
        }
}

void LoadSprite(LTexture &Textt, string path, int frame, int timedelay, int numsheets, bool flip) {
    if(path != "-1" && !Textt.loadFromFile(path.c_str())) {
        cout<<"Khong mo duoc link sau: "<<path<<"\n";
        exit(0);
    }

    int xsum=Textt.getWidth();
    int ysum=Textt.getHeight();

    if(numsheets == 0) { //nếu không phải objectile thì đầu vào là 0
        numsheets = xsum/ysum;
    }

    SDL_Rect KichThuoc[numsheets+1];
    for(int i=0; i<numsheets; i++) {
        KichThuoc[i].x= i*(xsum/numsheets);
        KichThuoc[i].y= 0;
        KichThuoc[i].w= xsum/numsheets;
        KichThuoc[i].h= ysum;
    }

    SDL_Rect* currentClip = &KichThuoc[ (frame / timedelay)%numsheets ];
    Textt.render( Textt.xx , 0, currentClip, flip );
}

string taolink(int id, string thaotac) {
    string res="TroopSprite/";
    char c='0'+id;
    res+=c;
    res+='/';
    res+=thaotac;
    res+=".png";
    return res;
}

void tancong(Troop &attacker, Troop &defender) {
    int satthuong=attacker.dame;
    if(attacker.binhchung == 1 && defender.binhchung == 2) satthuong*=2;
    if(attacker.binhchung == 2 && defender.binhchung == 3) satthuong*=2;
    if(attacker.binhchung == 3 && defender.binhchung == 1) satthuong*=2;
    if(attacker.id == 2 && defender.id == 3) satthuong= satthuong/2*3;

    defender.HP -= satthuong;
}

void Work(Troop &doituong) {
    bool EnemyInRange=false;
    for(int i=0; i<danhsachquan.size(); i++) {
        if(danhsachquan[i].phe == doituong.phe) continue;
        if( ((abs(doituong.r - danhsachquan[i].l) <= doituong.range) && !doituong.phe )  ||  (( abs(danhsachquan[i].r - doituong.l) <= doituong.range ) && doituong.phe) ) {
            EnemyInRange=true;
            break;
        }
    }

    bool AllyInFrontOfArcher=false;
    for(int i=0; i<danhsachquan.size(); i++) {
        if(danhsachquan[i].phe != doituong.phe) continue;
        if(danhsachquan[i].stt == doituong.stt) continue;
        if( ( doituong.r < danhsachquan[i].l && !doituong.phe )  ||  (danhsachquan[i].r < doituong.l && doituong.phe) ) {
            AllyInFrontOfArcher=true;
            break;
        }
    }

    int khoangcachcho=5;
    if(doituong.id==3) khoangcachcho=0;
    int deltax=doituong.SPD;

    bool CanMove=true;
    for(int i=0; i<danhsachquan.size(); i++) {
        if(danhsachquan[i].stt == doituong.stt) continue;
        if(doituong.phe==danhsachquan[i].phe)  khoangcachcho=5;
        if(doituong.phe==danhsachquan[i].phe && danhsachquan[i].stt<doituong.stt)
            if( max(danhsachquan[i].l, doituong.l) <= min(danhsachquan[i].r, doituong.r) ) CanMove=false;
        if( ((abs(doituong.r - danhsachquan[i].l) <= khoangcachcho) && !doituong.phe )  ||  (( abs(danhsachquan[i].r - doituong.l) <= khoangcachcho ) && doituong.phe) ) {
            CanMove=false;
            break;
        }
    }


    if(doituong.HP <= 0) { //kiểm tra xem có ở ngưỡng máu tử hay không
        if(doituong.deadframe<=6*delays) { //gọi từ 0 -> được 6*delays lần từ 0-47, khi ở 47 thì đã có cộng luôn lên 6*delays để erase đối tượng
            LoadSprite(doituong.Textt, taolink(doituong.id, "Death"), doituong.deadframe, delays, 0, doituong.phe);
            doituong.deadframe++;
            if(doituong.deadframe==6*delays) ClearTroop(doituong.stt);
        }
    }
    else {
        if(EnemyInRange) {
            if(doituong.id==3) { //TH đặc biệt -> tấn công xong die luôn
                if(doituong.deadframe==0) doituong.HP=2000; //fix đang nổ thì bị pháp sư giết -> cancel đòn nổ
                LoadSprite(doituong.Textt, taolink(doituong.id, "Attack"), doituong.deadframe, delays, 0, doituong.phe); //vì con cá nổ xong cũng đi luôn -> dùng sài tạm biến deadframe thay biến attackframe
                if(doituong.deadframe==3*delays) {
                    for(int i=0; i<danhsachquan.size(); i++) {
                        if(danhsachquan[i].phe == doituong.phe) continue;
                        if(abs(danhsachquan[i].r - doituong.l) <= doituong.range  ||  abs(danhsachquan[i].l - doituong.r) <= doituong.range) {
                            tancong(doituong, danhsachquan[i]);
                            break;
                        }
                    }
                }
                doituong.deadframe++;
                if(doituong.deadframe==6*delays) ClearTroop(doituong.stt);
            }
            else if(doituong.attackframe<(6*delays)) { //trong chu trình tấn công -> chạy hoạt ảnh tấn công, tấn công và di chuyển nếu có thể
                if(doituong.id==5 && AllyInFrontOfArcher) LoadSprite(doituong.Textt, taolink(doituong.id, "Attack2"), doituong.attackframe, delays, 0, doituong.phe);
                else LoadSprite(doituong.Textt, taolink(doituong.id, "Attack"), doituong.attackframe, delays, 0, doituong.phe);

                if( doituong.attackframe == (6*delays-1) ) {
                    //xác định kẻ địch gần nhất
                    int mn=1000, sttdich=0;
                    for(int i=0; i<danhsachquan.size(); i++) {
                        if(danhsachquan[i].phe == doituong.phe) continue;
                        if( abs(doituong.r - danhsachquan[i].l) <= doituong.range  &&  !doituong.phe  &&  abs(doituong.r - danhsachquan[i].l) < mn ) {
                            mn = abs(doituong.r - danhsachquan[i].l);
                            sttdich=i;
                        }
                        if( abs(danhsachquan[i].r - doituong.l) <= doituong.range  &&  doituong.phe  &&  abs(danhsachquan[i].r - doituong.l) < mn ) {
                            mn =  abs(danhsachquan[i].r - doituong.l);
                            sttdich=i;
                        }
                    }
                    tancong(doituong, danhsachquan[sttdich]);
                }

                doituong.attackframe++;
                if(doituong.attackframe==6*delays) doituong.cooldownframe=0;
            }
            else { //không trong đợt tấn công -> tiến tiếp hoặc đứng yên đợi
                if(CanMove) {
                    LoadSprite(doituong.Textt, taolink(doituong.id, "Walk"), frame, delays, 0, doituong.phe);
                    doituong.Textt.xx += deltax;
                    doituong.l += deltax;
                    doituong.r += deltax;
                }
                else LoadSprite(doituong.Textt, taolink(doituong.id, "Idle"), frame, delays, 0, doituong.phe);

                if(doituong.cooldownframe < 18*delays) doituong.cooldownframe++;
                if(doituong.cooldownframe == 18*delays) doituong.attackframe=0;
            }

        }
        else if(CanMove) {
            LoadSprite(doituong.Textt, taolink(doituong.id, "Walk"), frame, delays, 0, doituong.phe);
            doituong.Textt.xx += deltax;
            doituong.l += deltax;
            doituong.r += deltax;

            if(doituong.cooldownframe < 18*delays) doituong.cooldownframe++;
            if(doituong.cooldownframe == 18*delays) doituong.attackframe=0;
        }
        else {
            LoadSprite(doituong.Textt, taolink(doituong.id, "Idle"), frame, delays, 0, doituong.phe);

            if(doituong.cooldownframe < 18*delays) doituong.cooldownframe++;
            if(doituong.cooldownframe == 18*delays) doituong.attackframe=0;
        }
    }
}

void LoadSpriteHero(LTexture &Textt, string path, int frame, int timedelay, int numsheets, bool flip) {
    if(path != "-1" && !Textt.loadFromFile(path.c_str())) {
        cout<<"Khong mo duoc link sau: "<<path<<"\n";
        exit(0);
    }

    int xsum=Textt.getWidth();
    int ysum=Textt.getHeight();

    if(numsheets == 0) { //nếu không phải objectile thì đầu vào là 0
        numsheets = xsum/ysum;
    }

    SDL_Rect KichThuoc[numsheets+1];
    for(int i=0; i<numsheets; i++) {
        KichThuoc[i].x= 120+i*(xsum/numsheets);
        KichThuoc[i].y= 30;
        KichThuoc[i].w= 240;
        KichThuoc[i].h= 240;
    }

    SDL_Rect* currentClip = &KichThuoc[ (frame / timedelay)%numsheets ];
    Textt.render( Textt.xx , 0, currentClip, flip );
}

void WorkHero(Troop &doituong) {
    bool EnemyInRange=false;
    for(int i=0; i<danhsachquan.size(); i++) {
        if(danhsachquan[i].phe == doituong.phe) continue;
        if( ((abs(doituong.r - danhsachquan[i].l) <= doituong.range) && !doituong.phe )  ||  (( abs(danhsachquan[i].r - doituong.l) <= doituong.range ) && doituong.phe) ) {
            EnemyInRange=true;
            break;
        }
    }

    int khoangcachcho=5;
    int deltax=doituong.SPD;

    bool CanMove=true;
    for(int i=0; i<danhsachquan.size(); i++) {
        if(danhsachquan[i].stt == doituong.stt) continue;
        if( ((abs(doituong.r - danhsachquan[i].l) <= khoangcachcho) && !doituong.phe )  ||  (( abs(danhsachquan[i].r - doituong.l) <= khoangcachcho ) && doituong.phe) ) {
            CanMove=false;
            break;
        }
    }


    if(doituong.HP <= 0) { //kiểm tra xem có ở ngưỡng máu tử hay không
        if(doituong.deadframe<=6*delays) { //gọi từ 0 -> được 6*delays lần từ 0-47, khi ở 47 thì đã có cộng luôn lên 6*delays để erase đối tượng
            LoadSpriteHero(doituong.Textt, taolink(doituong.id, "Death"), doituong.deadframe, delays, 0, doituong.phe);
            doituong.deadframe++;
            if(doituong.deadframe==6*delays) ClearTroop(doituong.stt);
        }
    }
    else {
        if(EnemyInRange) {
            if(doituong.attackframe<(6*delays)) { //trong chu trình tấn công -> chạy hoạt ảnh tấn công, tấn công và di chuyển nếu có thể
                LoadSpriteHero(doituong.Textt, taolink(doituong.id, "Attack"), doituong.attackframe, delays, 0, doituong.phe);

                if( doituong.attackframe == (6*delays-1) ) {
                    //xác định kẻ địch gần nhất
                    int mn=1000, sttdich=0;
                    for(int i=0; i<danhsachquan.size(); i++) {
                        if(danhsachquan[i].phe == doituong.phe) continue;
                        if( abs(doituong.r - danhsachquan[i].l) <= doituong.range  &&  !doituong.phe  &&  abs(doituong.r - danhsachquan[i].l) < mn ) {
                            mn = abs(doituong.r - danhsachquan[i].l);
                            sttdich=i;
                        }
                        if( abs(danhsachquan[i].r - doituong.l) <= doituong.range  &&  doituong.phe  &&  abs(danhsachquan[i].r - doituong.l) < mn ) {
                            mn =  abs(danhsachquan[i].r - doituong.l);
                            sttdich=i;
                        }
                    }
                    tancong(doituong, danhsachquan[sttdich]);
                }

                doituong.attackframe++;
                if(doituong.attackframe==6*delays) doituong.cooldownframe=0;
            }
            else { //không trong đợt tấn công -> tiến tiếp hoặc đứng yên đợi
                if(CanMove) {
                    LoadSpriteHero(doituong.Textt, taolink(doituong.id, "Walk"), frame, delays, 0, doituong.phe);
                    doituong.Textt.xx += deltax;
                    doituong.l += deltax;
                    doituong.r += deltax;
                }
                else LoadSpriteHero(doituong.Textt, taolink(doituong.id, "Idle"), frame, delays, 0, doituong.phe);

                if(doituong.cooldownframe < 18*delays) doituong.cooldownframe++;
                if(doituong.cooldownframe == 18*delays) doituong.attackframe=0;
            }

        }
        else if(CanMove) {
            LoadSpriteHero(doituong.Textt, taolink(doituong.id, "Walk"), frame, delays, 0, doituong.phe);
            doituong.Textt.xx += deltax;
            doituong.l += deltax;
            doituong.r += deltax;

            if(doituong.cooldownframe < 18*delays) doituong.cooldownframe++;
            if(doituong.cooldownframe == 18*delays) doituong.attackframe=0;
        }
        else {
            LoadSpriteHero(doituong.Textt, taolink(doituong.id, "Idle"), frame, delays, 0, doituong.phe);

            if(doituong.cooldownframe < 18*delays) doituong.cooldownframe++;
            if(doituong.cooldownframe == 18*delays) doituong.attackframe=0;
        }
    }
}

bool AImove(bool hard, int DoiNha){
    int timesummon=400;
    if(hard || (DoiNha==2) ) timesummon=300;

    int l, r;
    if(DoiNha==2) l=1, r=3;
    else l=4, r=6;

    int id=Rand(l, r);
    if(hard && Rand(1, 2)==1 && !binhchungplayer.empty()) {
        id=1;
        if(DoiNha==3) id=4;

        if(binhchungplayer.front()==1) id+=2;
        if(binhchungplayer.front()==3) id++;
    }

    if(frame%timesummon==0) CreateTroop( id, 1, hard );
}